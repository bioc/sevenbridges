{
  "class": "Workflow",
  "steps": [
    {
      "id": "#STAR_Genome_Generate",
      "run": {
        "successCodes": [],
        "sbg:createdBy": "bix-demo",
        "description": "STAR Genome Generate is a tool that generates genome index files. One set of files should be generated per each genome/annotation combination. Once produced, these files could be used as long as genome/annotation combination stays the same. Also, STAR Genome Generate which produced these files and STAR aligner using them must be the same toolkit version.",
        "sbg:id": "sevenbridges/public-apps/star-genome-generate/1",
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "hints": [
          {
            "dockerImageId": "a4b0ad2c3cae",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_d/star:2.4.2a"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 15
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000
          }
        ],
        "baseCommand": [
          "mkdir",
          "genomeDir",
          "&&",
          "/opt/STAR",
          "--runMode",
          "genomeGenerate",
          "--genomeDir",
          "./genomeDir",
          "--runThreadN",
          {
            "class": "Expression",
            "script": "{\n  return $job.allocatedResources.cpu\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:modifiedOn": 1450911470,
        "sbg:toolkitVersion": "2.4.2a",
        "stdout": "",
        "sbg:links": [
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/alexdobin/STAR/releases",
            "label": "Releases"
          },
          {
            "id": "https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf",
            "label": "Manual"
          },
          {
            "id": "https://groups.google.com/forum/#!forum/rna-star",
            "label": "Support"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/23104886",
            "label": "Publication"
          }
        ],
        "sbg:revision": 1,
        "sbg:cmdPreview": "mkdir genomeDir && /opt/STAR --runMode genomeGenerate --genomeDir ./genomeDir --runThreadN 15 --genomeFastaFiles /sbgenomics/test-data/chr20.fa --genomeChrBinNbits genomeChrBinNbits --genomeSAindexNbases 0 --genomeSAsparseD 0 --sjdbGTFfeatureExon sjdbGTFfeatureExon --sjdbGTFtagExonParentTranscript sjdbGTFtagExonParentTranscript --sjdbGTFtagExonParentGene sjdbGTFtagExonParentGene --sjdbOverhang 0 --sjdbScore 0 --sjdbGTFchrPrefix sjdbGTFchrPrefix  --sjdbGTFfile /demo/test-files/chr20.gtf  && tar -vcf genome.tar ./genomeDir /sbgenomics/test-data/chr20.fa",
        "x": 384.0832265913437,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "sbg:category": "Splice junctions db parameters",
            "type": [
              "null",
              "int"
            ],
            "description": "Extra alignment score for alignments that cross database junctions.",
            "label": "Extra alignment score",
            "id": "#sjdbScore",
            "required": false,
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--sjdbScore"
            }
          },
          {
            "sbg:includeInPorts": true,
            "sbg:category": "Splice junctions db parameters",
            "type": [
              "null",
              "int"
            ],
            "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used.",
            "label": "\"Overhang\" length",
            "id": "#sjdbOverhang",
            "required": false,
            "sbg:toolDefaultValue": "100",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--sjdbOverhang"
            }
          },
          {
            "sbg:category": "Splice junctions db parameters",
            "sbg:toolDefaultValue": "transcript_id",
            "type": [
              "null",
              "string"
            ],
            "label": "Exons' parents name",
            "description": "Tag name to be used as exons' transcript-parents.",
            "id": "#sjdbGTFtagExonParentTranscript",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--sjdbGTFtagExonParentTranscript"
            }
          },
          {
            "sbg:category": "Splice junctions db parameters",
            "sbg:toolDefaultValue": "gene_id",
            "type": [
              "null",
              "string"
            ],
            "label": "Gene name",
            "description": "Tag name to be used as exons' gene-parents.",
            "id": "#sjdbGTFtagExonParentGene",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--sjdbGTFtagExonParentGene"
            }
          },
          {
            "sbg:category": "Basic",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "label": "Splice junction file",
            "description": "Gene model annotations and/or known transcripts.",
            "id": "#sjdbGTFfile",
            "sbg:fileTypes": "GTF, GFF, TXT",
            "required": false
          },
          {
            "sbg:category": "Splice junctions db parameters",
            "sbg:toolDefaultValue": "exon",
            "type": [
              "null",
              "string"
            ],
            "label": "Set exons feature",
            "description": "Feature type in GTF file to be used as exons for building transcripts.",
            "id": "#sjdbGTFfeatureExon",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--sjdbGTFfeatureExon"
            }
          },
          {
            "sbg:category": "Splice junctions db parameters",
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              "string"
            ],
            "label": "Chromosome names",
            "description": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes).",
            "id": "#sjdbGTFchrPrefix",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--sjdbGTFchrPrefix"
            }
          },
          {
            "sbg:category": "Genome generation parameters",
            "sbg:toolDefaultValue": "1",
            "type": [
              "null",
              "int"
            ],
            "label": "Suffux array sparsity",
            "description": "Distance between indices: use bigger numbers to decrease needed RAM at the cost of mapping speed reduction (int>0).",
            "id": "#genomeSAsparseD",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--genomeSAsparseD"
            }
          },
          {
            "sbg:category": "Genome generation parameters",
            "sbg:toolDefaultValue": "14",
            "type": [
              "null",
              "int"
            ],
            "label": "Pre-indexing string length",
            "description": "Length (bases) of the SA pre-indexing string. Typically between 10 and 15. Longer strings will use much more memory, but allow faster searches. For small genomes, this number needs to be scaled down, with a typical value of min(14, log2(GenomeLength)/2 - 1). For example, for 1 megaBase genome, this is equal to 9, for 100 kiloBase genome, this is equal to 7.",
            "id": "#genomeSAindexNbases",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--genomeSAindexNbases"
            }
          },
          {
            "sbg:category": "Basic",
            "type": [
              "File"
            ],
            "label": "Genome fasta files",
            "description": "Reference sequence to which to align the reads.",
            "id": "#genomeFastaFiles",
            "sbg:fileTypes": "FASTA, FA",
            "required": true,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--genomeFastaFiles"
            }
          },
          {
            "sbg:category": "Genome generation parameters",
            "sbg:toolDefaultValue": "18",
            "type": [
              "null",
              "string"
            ],
            "label": "Bins size",
            "description": "Set log2(chrBin), where chrBin is the size (bits) of the bins for genome storage: each chromosome will occupy an integer number of bins. If you are using a genome with a large (>5,000) number of chrosomes/scaffolds, you may need to reduce this number to reduce RAM consumption. The following scaling is recomended: genomeChrBinNbits = min(18, log2(GenomeLength/NumberOfReferences)). For example, for 3 gigaBase genome with 100,000 chromosomes/scaffolds, this is equal to 15.",
            "id": "#genomeChrBinNbits",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--genomeChrBinNbits"
            }
          }
        ],
        "sbg:project": "bix-demo/star-2-4-2a-demo",
        "label": "STAR Genome Generate",
        "y": 446.4998956719985,
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 15
          },
          "inputs": {
            "sjdbScore": 0,
            "sjdbGTFfeatureExon": "sjdbGTFfeatureExon",
            "sjdbOverhang": 0,
            "sjdbGTFtagExonParentTranscript": "sjdbGTFtagExonParentTranscript",
            "genomeChrBinNbits": "genomeChrBinNbits",
            "genomeSAsparseD": 0,
            "sjdbGTFfile": [
              {
                "size": 0,
                "secondaryFiles": [],
                "class": "File",
                "path": "/demo/test-files/chr20.gtf"
              }
            ],
            "sjdbGTFtagExonParentGene": "sjdbGTFtagExonParentGene",
            "genomeFastaFiles": {
              "size": 0,
              "secondaryFiles": [],
              "class": "File",
              "path": "/sbgenomics/test-data/chr20.fa"
            },
            "sjdbGTFchrPrefix": "sjdbGTFchrPrefix",
            "genomeSAindexNbases": 0
          }
        },
        "sbg:contributors": [
          "bix-demo"
        ],
        "sbg:createdOn": 1450911469,
        "sbg:validationErrors": [],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Genome Files",
            "description": "Genome files comprise binary genome sequence, suffix arrays, text chromosome names/lengths, splice junctions coordinates, and transcripts/genes information.",
            "id": "#genome",
            "sbg:fileTypes": "TAR",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*.tar"
            }
          }
        ],
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:latestRevision": 1,
        "sbg:modifiedBy": "bix-demo",
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "stdin": "",
        "sbg:toolkit": "STAR",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911469,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911470,
            "sbg:revision": 1
          }
        ],
        "id": "sevenbridges/public-apps/star-genome-generate/1",
        "arguments": [
          {
            "separate": true,
            "valueFrom": "&& tar -vcf genome.tar ./genomeDir",
            "position": 99
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\t\n  var sjFormat = \"False\"\n  var gtfgffFormat = \"False\"\n  var list = $job.inputs.sjdbGTFfile\n  var paths_list = []\n  var joined_paths = \"\"\n  \n  if (list) {\n    list.forEach(function(f){return paths_list.push(f.path)})\n    joined_paths = paths_list.join(\" \")\n\n\n    paths_list.forEach(function(f){\n      ext = f.replace(/^.*\\./, '')\n      if (ext == \"gff\" || ext == \"gtf\") {\n        gtfgffFormat = \"True\"\n        return gtfgffFormat\n      }\n      if (ext == \"txt\") {\n        sjFormat = \"True\"\n        return sjFormat\n      }\n    })\n\n    if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave != \"None\") {\n      if (sjFormat == \"True\") {\n        return \"--sjdbFileChrStartEnd \".concat(joined_paths)\n      }\n      else if (gtfgffFormat == \"True\") {\n        return \"--sjdbGTFfile \".concat(joined_paths)\n      }\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "temporaryFailCodes": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false
      },
      "inputs": [
        {
          "id": "#STAR_Genome_Generate.sjdbScore"
        },
        {
          "id": "#STAR_Genome_Generate.sjdbOverhang"
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFtagExonParentTranscript",
          "source": [
            "#sjdbGTFtagExonParentTranscript"
          ]
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFtagExonParentGene",
          "source": [
            "#sjdbGTFtagExonParentGene"
          ]
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFfile",
          "source": [
            "#sjdbGTFfile"
          ]
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFfeatureExon"
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFchrPrefix"
        },
        {
          "id": "#STAR_Genome_Generate.genomeSAsparseD"
        },
        {
          "id": "#STAR_Genome_Generate.genomeSAindexNbases"
        },
        {
          "id": "#STAR_Genome_Generate.genomeFastaFiles",
          "source": [
            "#genomeFastaFiles"
          ]
        },
        {
          "id": "#STAR_Genome_Generate.genomeChrBinNbits"
        }
      ],
      "outputs": [
        {
          "id": "#STAR_Genome_Generate.genome"
        }
      ],
      "sbg:x": 384.0832265913437,
      "sbg:y": 446.4998956719985
    },
    {
      "id": "#SBG_FASTQ_Quality_Detector",
      "run": {
        "successCodes": [],
        "sbg:createdBy": "bix-demo",
        "description": "FASTQ Quality Scale Detector detects which quality encoding scheme was used in your reads and automatically enters the proper value in the \"Quality Scale\" metadata field.",
        "sbg:id": "sevenbridges/public-apps/sbg-fastq-quality-detector/3",
        "sbg:toolAuthor": "Seven Bridges Genomics",
        "hints": [
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/tziotas/sbg_fastq_quality_scale_detector:1.0"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          }
        ],
        "baseCommand": [
          "python",
          "/opt/sbg_fastq_quality_scale_detector.py"
        ],
        "sbg:modifiedOn": 1450911314,
        "requirements": [],
        "stdout": "",
        "sbg:revision": 3,
        "sbg:cmdPreview": "python /opt/sbg_fastq_quality_scale_detector.py --fastq /path/to/fastq.ext /path/to/fastq.ext",
        "x": 375.33331789572907,
        "inputs": [
          {
            "type": [
              "File"
            ],
            "description": "FASTQ file.",
            "label": "Fastq",
            "id": "#fastq",
            "required": true,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--fastq"
            }
          }
        ],
        "sbg:project": "bix-demo/sbgtools-demo",
        "label": "SBG FASTQ Quality Detector",
        "sbg:latestRevision": 3,
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "fastq": {
              "size": 0,
              "secondaryFiles": [],
              "class": "File",
              "path": "/path/to/fastq.ext"
            }
          }
        },
        "sbg:contributors": [
          "bix-demo"
        ],
        "sbg:createdOn": 1450911312,
        "sbg:validationErrors": [],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Result",
            "description": "Source FASTQ file with updated metadata.",
            "id": "#result",
            "sbg:fileTypes": "FASTQ",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*.fastq"
            }
          }
        ],
        "sbg:categories": [
          "FASTQ-Processing"
        ],
        "y": 323.58331564068664,
        "sbg:modifiedBy": "bix-demo",
        "stdin": "",
        "sbg:toolkit": "SBGTools",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911312,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911314,
            "sbg:revision": 3
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911313,
            "sbg:revision": 1
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911313,
            "sbg:revision": 2
          }
        ],
        "id": "sevenbridges/public-apps/sbg-fastq-quality-detector/3",
        "arguments": [],
        "temporaryFailCodes": [],
        "sbg:license": "Apache License 2.0",
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false
      },
      "inputs": [
        {
          "id": "#SBG_FASTQ_Quality_Detector.fastq",
          "source": [
            "#fastq"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SBG_FASTQ_Quality_Detector.result"
        }
      ],
      "sbg:x": 375.33331789572907,
      "sbg:y": 323.58331564068664,
      "scatter": "#SBG_FASTQ_Quality_Detector.fastq"
    },
    {
      "id": "#Picard_SortSam",
      "run": {
        "successCodes": [],
        "sbg:createdBy": "bix-demo",
        "description": "Picard SortSam sorts the input SAM or BAM. Input and output formats are determined by the file extension.",
        "sbg:id": "sevenbridges/public-apps/picard-sortsam-1-140/2",
        "sbg:toolAuthor": "Broad Institute",
        "hints": [
          {
            "dockerImageId": "eab0e70b6629",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/mladenlsbg/picard:1.140"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.memory_per_job){\n  \treturn $job.inputs.memory_per_job\n  }\n  \treturn 2048\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "java",
          {
            "class": "Expression",
            "script": "{   \n  if($job.inputs.memory_per_job){\n    return '-Xmx'.concat($job.inputs.memory_per_job, 'M')\n  }   \n  \treturn '-Xmx2048M'\n}",
            "engine": "#cwl-js-engine"
          },
          "-jar",
          "/opt/picard-tools-1.140/picard.jar",
          "SortSam"
        ],
        "sbg:modifiedOn": 1450911170,
        "sbg:toolkitVersion": "1.140",
        "stdout": "",
        "sbg:links": [
          {
            "id": "http://broadinstitute.github.io/picard/index.html",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/picard/releases/tag/1.138",
            "label": "Source Code"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Wiki"
          },
          {
            "id": "https://github.com/broadinstitute/picard/zipball/master",
            "label": "Download"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Publication"
          }
        ],
        "sbg:revision": 2,
        "sbg:cmdPreview": "java -Xmx2048M -jar /opt/picard-tools-1.140/picard.jar SortSam OUTPUT=example.tested.sorted.bam INPUT=/root/dir/example.tested.bam SORT_ORDER=coordinate   INPUT=/root/dir/example.tested.bam SORT_ORDER=coordinate  /root/dir/example.tested.bam",
        "x": 773.083180715633,
        "inputs": [
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "SILENT",
            "type": [
              "null",
              {
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "type": "enum",
                "name": "validation_stringency"
              }
            ],
            "label": "Validation stringency",
            "description": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. This option can be set to 'null' to clear the default value. Possible values: {STRICT, LENIENT, SILENT}.",
            "id": "#validation_stringency",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "VALIDATION_STRINGENCY=",
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.validation_stringency)\n  {\n    return $job.inputs.validation_stringency\n  }\n  else\n  {\n    return \"SILENT\"\n  }\n}",
                "engine": "#cwl-js-engine"
              }
            }
          },
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "Coordinate",
            "type": [
              {
                "symbols": [
                  "Unsorted",
                  "Queryname",
                  "Coordinate"
                ],
                "type": "enum",
                "name": "sort_order"
              }
            ],
            "label": "Sort order",
            "sbg:altPrefix": "SO",
            "description": "Sort order of the output file. Possible values: {unsorted, queryname, coordinate}.",
            "id": "#sort_order",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "position": 3,
              "prefix": "SORT_ORDER=",
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  p = $job.inputs.sort_order.toLowerCase()\n  return p\n}",
                "engine": "#cwl-js-engine"
              }
            }
          },
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "False",
            "type": [
              "null",
              {
                "symbols": [
                  "True",
                  "False"
                ],
                "type": "enum",
                "name": "quiet"
              }
            ],
            "label": "Quiet",
            "description": "This parameter indicates whether to suppress job-summary info on System.err. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
            "id": "#quiet",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "QUIET="
            }
          },
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "SAME AS INPUT",
            "type": [
              "null",
              {
                "symbols": [
                  "BAM",
                  "SAM",
                  "SAME AS INPUT"
                ],
                "type": "enum",
                "name": "output_type"
              }
            ],
            "label": "Output format",
            "description": "Since Picard tools can output both SAM and BAM files, user can choose the format of the output file.",
            "id": "#output_type"
          },
          {
            "sbg:toolDefaultValue": "2048",
            "id": "#memory_per_job",
            "type": [
              "null",
              "int"
            ],
            "description": "Amount of RAM memory to be used per job. Defaults to 2048 MB for single threaded jobs.",
            "label": "Memory per job"
          },
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "500000",
            "type": [
              "null",
              "int"
            ],
            "label": "Max records in RAM",
            "description": "When writing SAM files that need to be sorted, this parameter will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. This option can be set to 'null' to clear the default value.",
            "id": "#max_records_in_ram",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "MAX_RECORDS_IN_RAM="
            }
          },
          {
            "sbg:category": "File inputs",
            "type": [
              "File"
            ],
            "label": "Input BAM",
            "sbg:altPrefix": "I",
            "description": "The BAM or SAM file to sort.",
            "id": "#input_bam",
            "sbg:fileTypes": "BAM, SAM",
            "required": true,
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "position": 1,
              "prefix": "INPUT="
            }
          },
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "False",
            "type": [
              "null",
              {
                "symbols": [
                  "True",
                  "False"
                ],
                "type": "enum",
                "name": "create_index"
              }
            ],
            "label": "Create index",
            "description": "This parameter indicates whether to create a BAM index when writing a coordinate-sorted BAM file. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
            "id": "#create_index",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "position": 5,
              "prefix": "CREATE_INDEX="
            }
          },
          {
            "sbg:category": "Other input types",
            "sbg:toolDefaultValue": "5",
            "type": [
              "null",
              "int"
            ],
            "label": "Compression level",
            "description": "Compression level for all compressed files created (e.g. BAM and GELI). This option can be set to 'null' to clear the default value.",
            "id": "#compression_level",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "COMPRESSION_LEVEL="
            }
          }
        ],
        "sbg:project": "bix-demo/picard-1-140-demo",
        "label": "Picard SortSam",
        "y": 470.9165938595894,
        "sbg:job": {
          "allocatedResources": {
            "mem": 2048,
            "cpu": 1
          },
          "inputs": {
            "sort_order": "Coordinate",
            "input_bam": {
              "path": "/root/dir/example.tested.bam"
            },
            "memory_per_job": 2048,
            "output_type": null,
            "create_index": null
          }
        },
        "sbg:contributors": [
          "bix-demo"
        ],
        "sbg:createdOn": 1450911168,
        "sbg:validationErrors": [],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Sorted BAM/SAM",
            "description": "Sorted BAM or SAM file.",
            "id": "#sorted_bam",
            "sbg:fileTypes": "BAM, SAM",
            "outputBinding": {
              "secondaryFiles": [
                "^.bai",
                ".bai"
              ],
              "sbg:inheritMetadataFrom": "#input_bam",
              "glob": "*.sorted.?am",
              "sbg:metadata": {
                "__inherit__": "input_bam"
              }
            }
          }
        ],
        "sbg:categories": [
          "SAM/BAM-Processing"
        ],
        "sbg:latestRevision": 2,
        "sbg:modifiedBy": "bix-demo",
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "stdin": "",
        "sbg:toolkit": "Picard",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911168,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911169,
            "sbg:revision": 1
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911170,
            "sbg:revision": 2
          }
        ],
        "id": "sevenbridges/public-apps/picard-sortsam-1-140/2",
        "arguments": [
          {
            "separate": false,
            "prefix": "OUTPUT=",
            "order": 2,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  filename = $job.inputs.input_bam.path\n  ext = $job.inputs.output_type\n\nif (ext === \"BAM\")\n{\n    return filename.split('.').slice(0, -1).concat(\"sorted.bam\").join(\".\").replace(/^.*[\\\\\\/]/, '')\n    }\n\nelse if (ext === \"SAM\")\n{\n    return filename.split('.').slice(0, -1).concat(\"sorted.sam\").join('.').replace(/^.*[\\\\\\/]/, '')\n}\n\nelse \n{\n\treturn filename.split('.').slice(0, -1).concat(\"sorted.\"+filename.split('.').slice(-1)[0]).join(\".\").replace(/^.*[\\\\\\/]/, '')\n}\n}",
              "engine": "#cwl-js-engine"
            },
            "position": 0,
            "inputBinding": {
              "separate": false
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  filename = $job.inputs.input_bam.path\n  \n  /* figuring out output file type */\n  ext = $job.inputs.output_type\n  if (ext === \"BAM\")\n  {\n    out_extension = \"BAM\"\n  }\n  else if (ext === \"SAM\")\n  {\n    out_extension = \"SAM\"\n  }\n  else \n  {\n\tout_extension = filename.split('.').slice(-1)[0].toUpperCase()\n  }  \n  \n  /* if exist moving .bai in bam.bai */\n  if ($job.inputs.create_index === 'True' && $job.inputs.sort_order === 'Coordinate' && out_extension == \"BAM\")\n  {\n    \n    old_name = filename.split('.').slice(0, -1).concat('sorted.bai').join('.').replace(/^.*[\\\\\\/]/, '')\n    new_name = filename.split('.').slice(0, -1).concat('sorted.bam.bai').join('.').replace(/^.*[\\\\\\/]/, '')\n    return \"; mv \" + \" \" + old_name + \" \" + new_name\n  }\n\n}",
              "engine": "#cwl-js-engine"
            },
            "position": 1000
          }
        ],
        "temporaryFailCodes": [],
        "sbg:license": "MIT License, Apache 2.0 Licence",
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false
      },
      "inputs": [
        {
          "id": "#Picard_SortSam.validation_stringency",
          "default": "SILENT"
        },
        {
          "id": "#Picard_SortSam.sort_order",
          "default": "Coordinate"
        },
        {
          "id": "#Picard_SortSam.quiet"
        },
        {
          "id": "#Picard_SortSam.output_type"
        },
        {
          "id": "#Picard_SortSam.memory_per_job"
        },
        {
          "id": "#Picard_SortSam.max_records_in_ram"
        },
        {
          "id": "#Picard_SortSam.input_bam",
          "source": [
            "#STAR.aligned_reads"
          ]
        },
        {
          "id": "#Picard_SortSam.create_index",
          "default": "True"
        },
        {
          "id": "#Picard_SortSam.compression_level"
        }
      ],
      "outputs": [
        {
          "id": "#Picard_SortSam.sorted_bam"
        }
      ],
      "sbg:x": 773.083180715633,
      "sbg:y": 470.9165938595894
    },
    {
      "id": "#STAR",
      "run": {
        "successCodes": [],
        "sbg:createdBy": "bix-demo",
        "description": "STAR is an ultrafast universal RNA-seq aligner. It has very high mapping speed, accurate alignment of contiguous and spliced reads, detection of polyA-tails, non-canonical splices and chimeric (fusion) junctions. It works with reads starting from lengths ~15 bases up to ~300 bases. In case of having longer reads, use of STAR Long is recommended.",
        "sbg:id": "sevenbridges/public-apps/star/4",
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "hints": [
          {
            "dockerImageId": "a4b0ad2c3cae",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_d/star:2.4.2a"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000
          },
          {
            "class": "sbg:CPURequirement",
            "value": 15
          }
        ],
        "baseCommand": [
          "tar",
          "-xvf",
          {
            "class": "Expression",
            "script": "$job.inputs.genome.path",
            "engine": "#cwl-js-engine"
          },
          "&&",
          "/opt/STAR",
          "--runThreadN",
          {
            "class": "Expression",
            "script": "{\n  return $job.allocatedResources.cpu\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:modifiedOn": 1462889222,
        "sbg:toolkitVersion": "2.4.2a",
        "stdout": "",
        "sbg:links": [
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/alexdobin/STAR/releases",
            "label": "Releases"
          },
          {
            "id": "https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf",
            "label": "Manual"
          },
          {
            "id": "https://groups.google.com/forum/#!forum/rna-star",
            "label": "Support"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/23104886",
            "label": "Publication"
          }
        ],
        "sbg:cmdPreview": "tar -xvf genome.ext && /opt/STAR --runThreadN 15  --readFilesCommand bzcat  --sjdbGTFfile /demo/test-data/chr20.gtf  --sjdbGTFchrPrefix chrPrefix --sjdbInsertSave Basic  --twopass1readsN 0  --chimOutType WithinBAM  --outSAMattrRGline ID:1 CN:illumina PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample  --quantMode TranscriptomeSAM --outFileNamePrefix ./mate_1.fastq.bz2.  --readFilesIn /test-data/mate_1.fastq.bz2  && tar -vcf mate_1.fastq.bz2._STARgenome.tar ./mate_1.fastq.bz2._STARgenome  && mv mate_1.fastq.bz2.Unmapped.out.mate1 mate_1.fastq.bz2.Unmapped.out.mate1.fastq",
        "sbg:revision": 4,
        "sbg:image_url": null,
        "x": 623.9999999999999,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "sbg:category": "Windows, Anchors, Binning",
            "type": [
              "null",
              "int"
            ],
            "description": "=log2(winFlank), where win Flank is the size of the left and right flanking regions for each window (int>0).",
            "label": "Flanking regions size",
            "id": "#winFlankNbins",
            "required": false,
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winFlankNbins"
            }
          },
          {
            "sbg:includeInPorts": true,
            "sbg:category": "Windows, Anchors, Binning",
            "type": [
              "null",
              "int"
            ],
            "description": "=log2(winBin), where winBin is the size of the bin for the windows/clustering, each window will occupy an integer number of bins (int>0).",
            "label": "Bin size",
            "id": "#winBinNbits",
            "required": false,
            "sbg:toolDefaultValue": "16",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winBinNbits"
            }
          },
          {
            "sbg:category": "Windows, Anchors, Binning",
            "sbg:toolDefaultValue": "50",
            "type": [
              "null",
              "int"
            ],
            "label": "Max loci anchors",
            "description": "Max number of loci anchors are allowed to map to (int>0).",
            "id": "#winAnchorMultimapNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winAnchorMultimapNmax"
            }
          },
          {
            "sbg:category": "Windows, Anchors, Binning",
            "sbg:toolDefaultValue": "9",
            "type": [
              "null",
              "int"
            ],
            "label": "Max bins between anchors",
            "description": "Max number of bins between two anchors that allows aggregation of anchors into one window (int>0).",
            "id": "#winAnchorDistNbins",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winAnchorDistNbins"
            }
          },
          {
            "sbg:category": "2-pass mapping",
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Basic"
                ],
                "type": "enum",
                "name": "twopassMode"
              }
            ],
            "label": "Two-pass mode",
            "description": "2-pass mapping mode. None: 1-pass mapping; Basic: basic 2-pass mapping, with all 1st pass junctions inserted into the genome indices on the fly.",
            "id": "#twopassMode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--twopassMode"
            }
          },
          {
            "sbg:category": "2-pass mapping",
            "sbg:toolDefaultValue": "-1",
            "type": [
              "null",
              "int"
            ],
            "label": "Reads to process in 1st step",
            "description": "Number of reads to process for the 1st step. 0: 1-step only, no 2nd pass; use very large number to map all reads in the first step (int>0).",
            "id": "#twopass1readsN"
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "2",
            "type": [
              "null",
              "int"
            ],
            "label": "Extra alignment score",
            "description": "Extra alignment score for alignments that cross database junctions.",
            "id": "#sjdbScore"
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "100",
            "type": [
              "null",
              "int"
            ],
            "label": "\"Overhang\" length",
            "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used.",
            "id": "#sjdbOverhang"
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "Basic",
                  "All",
                  "None"
                ],
                "type": "enum",
                "name": "sjdbInsertSave"
              }
            ],
            "label": "Save junction files",
            "description": "Which files to save when sjdb junctions are inserted on the fly at the mapping step. None: not saving files at all; Basic: only small junction/transcript files; All: all files including big Genome, SA and SAindex. These files are output as archive.",
            "id": "#sjdbInsertSave"
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "transcript_id",
            "type": [
              "null",
              "string"
            ],
            "label": "Exons' parents name",
            "description": "Tag name to be used as exons' transcript-parents.",
            "id": "#sjdbGTFtagExonParentTranscript"
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "gene_id",
            "type": [
              "null",
              "string"
            ],
            "label": "Gene name",
            "description": "Tag name to be used as exons' gene-parents.",
            "id": "#sjdbGTFtagExonParentGene"
          },
          {
            "sbg:category": "Basic",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "label": "Splice junction file",
            "description": "Gene model annotations and/or known transcripts. No need to include this input, except in case of using \"on the fly\" annotations.",
            "id": "#sjdbGTFfile",
            "sbg:fileTypes": "GTF, GFF, TXT",
            "required": false
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "exon",
            "type": [
              "null",
              "string"
            ],
            "label": "Set exons feature",
            "description": "Feature type in GTF file to be used as exons for building transcripts.",
            "id": "#sjdbGTFfeatureExon"
          },
          {
            "sbg:category": "Splice junctions database",
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              "string"
            ],
            "label": "Chromosome names",
            "description": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes).",
            "id": "#sjdbGTFchrPrefix"
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "1.0",
            "type": [
              "null",
              "float"
            ],
            "label": "Search start point normalized",
            "description": "seedSearchStartLmax normalized to read length (sum of mates' lengths for paired-end reads).",
            "id": "#seedSearchStartLmaxOverLread",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedSearchStartLmaxOverLread"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "50",
            "type": [
              "null",
              "int"
            ],
            "label": "Search start point",
            "description": "Defines the search start point through the read - the read is split into pieces no longer than this value (int>0).",
            "id": "#seedSearchStartLmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedSearchStartLmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Max seed length",
            "description": "Defines the maximum length of the seeds, if =0 max seed length is infinite (int>=0).",
            "id": "#seedSearchLmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedSearchLmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "50",
            "type": [
              "null",
              "int"
            ],
            "label": "Max seeds per window",
            "description": "Max number of seeds per window (int>=0).",
            "id": "#seedPerWindowNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedPerWindowNmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "1000",
            "type": [
              "null",
              "int"
            ],
            "label": "Max seeds per read",
            "description": "Max number of seeds per read (int>=0).",
            "id": "#seedPerReadNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedPerReadNmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "10",
            "type": [
              "null",
              "int"
            ],
            "label": "Max one-seed loci per window",
            "description": "Max number of one seed loci per window (int>=0).",
            "id": "#seedNoneLociPerWindow",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedNoneLociPerWindow"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "10000",
            "type": [
              "null",
              "int"
            ],
            "label": "Filter pieces for stitching",
            "description": "Only pieces that map fewer than this value are utilized in the stitching procedure (int>=0).",
            "id": "#seedMultimapNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedMultimapNmax"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "1",
            "type": [
              "null",
              "int"
            ],
            "label": "Max score reduction",
            "description": "Maximum score reduction while searching for SJ boundaries in the stitching step.",
            "id": "#scoreStitchSJshift",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreStitchSJshift"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-2",
            "type": [
              "null",
              "int"
            ],
            "label": "Insertion Open Penalty",
            "description": "Insertion open penalty.",
            "id": "#scoreInsOpen",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreInsOpen"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-2",
            "type": [
              "null",
              "int"
            ],
            "label": "Insertion extension penalty",
            "description": "Insertion extension penalty per base (in addition to --scoreInsOpen).",
            "id": "#scoreInsBase",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreInsBase"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-0.25",
            "type": [
              "null",
              "float"
            ],
            "label": "Log scaled score",
            "description": "Extra score logarithmically scaled with genomic length of the alignment: <int>*log2(genomicLength).",
            "id": "#scoreGenomicLengthLog2scale",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGenomicLengthLog2scale"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-8",
            "type": [
              "null",
              "int"
            ],
            "label": "Non-canonical gap open",
            "description": "Non-canonical gap open penalty (in addition to --scoreGap).",
            "id": "#scoreGapNoncan",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGapNoncan"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-4",
            "type": [
              "null",
              "int"
            ],
            "label": "GC/AG and CT/GC gap open",
            "description": "GC/AG and CT/GC gap open penalty (in addition to --scoreGap).",
            "id": "#scoreGapGCAG",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGapGCAG"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-8",
            "type": [
              "null",
              "int"
            ],
            "label": "AT/AC and GT/AT gap open",
            "description": "AT/AC and GT/AT gap open penalty (in addition to --scoreGap).",
            "id": "#scoreGapATAC",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGapATAC"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Gap open penalty",
            "description": "Gap open penalty.",
            "id": "#scoreGap",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGap"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-2",
            "type": [
              "null",
              "int"
            ],
            "label": "Deletion open penalty",
            "description": "Deletion open penalty.",
            "id": "#scoreDelOpen",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreDelOpen"
            }
          },
          {
            "sbg:category": "Scoring",
            "sbg:toolDefaultValue": "-2",
            "type": [
              "null",
              "int"
            ],
            "label": "Deletion extension penalty",
            "description": "Deletion extension penalty per base (in addition to --scoreDelOpen).",
            "id": "#scoreDelBase",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreDelBase"
            }
          },
          {
            "sbg:category": "Read group",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "label": "Sequencing center",
            "description": "Specify the sequencing center for RG line.",
            "id": "#rg_seq_center"
          },
          {
            "sbg:category": "Read group",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "label": "Sample ID",
            "description": "Specify the sample ID for RG line.",
            "id": "#rg_sample_id"
          },
          {
            "sbg:category": "Read group",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "label": "Platform unit ID",
            "description": "Specify the platform unit ID for RG line.",
            "id": "#rg_platform_unit_id"
          },
          {
            "sbg:category": "Read group",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              {
                "symbols": [
                  "LS 454",
                  "Helicos",
                  "Illumina",
                  "ABI SOLiD",
                  "Ion Torrent PGM",
                  "PacBio"
                ],
                "type": "enum",
                "name": "rg_platform"
              }
            ],
            "label": "Platform",
            "description": "Specify the version of the technology that was used for sequencing or assaying.",
            "id": "#rg_platform"
          },
          {
            "sbg:category": "Read group",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "label": "Median fragment length",
            "description": "Specify the median fragment length for RG line.",
            "id": "#rg_mfl"
          },
          {
            "sbg:category": "Read group",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "label": "Library ID",
            "description": "Specify the library ID for RG line.",
            "id": "#rg_library_id"
          },
          {
            "sbg:category": "Basic",
            "type": [
              {
                "name": "reads",
                "type": "array",
                "items": "File"
              }
            ],
            "label": "Read sequence",
            "description": "Read sequence.",
            "id": "#reads",
            "sbg:fileTypes": "FASTA, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "required": true,
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 10,
              "valueFrom": {
                "class": "Expression",
                "script": "{\t\n  var list = [].concat($job.inputs.reads)\n  \n  var resp = []\n  \n  if (list.length == 1){\n    resp.push(list[0].path)\n    \n  }else if (list.length == 2){    \n    \n    left = \"\"\n    right = \"\"\n      \n    for (index = 0; index < list.length; ++index) {\n      \n      if (list[index].metadata != null){\n        if (list[index].metadata.paired_end == 1){\n          left = list[index].path\n        }else if (list[index].metadata.paired_end == 2){\n          right = list[index].path\n        }\n      }\n    }\n    \n    if (left != \"\" && right != \"\"){      \n      resp.push(left)\n      resp.push(right)\n    }\n  }\n  else if (list.length > 2){\n    left = []\n    right = []\n      \n    for (index = 0; index < list.length; ++index) {\n      \n      if (list[index].metadata != null){\n        if (list[index].metadata.paired_end == 1){\n          left.push(list[index].path)\n        }else if (list[index].metadata.paired_end == 2){\n          right.push(list[index].path)\n        }\n      }\n    }\n    left_join = left.join()\n    right_join = right.join()\n    if (left != [] && right != []){      \n      resp.push(left_join)\n      resp.push(right_join)\n    }\t\n  }\n  \n  if(resp.length > 0){    \n    return \"--readFilesIn \".concat(resp.join(\" \"))\n  }\n}",
                "engine": "#cwl-js-engine"
              }
            }
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "NotEqual",
            "type": [
              "null",
              {
                "symbols": [
                  "NotEqual",
                  "Equal"
                ],
                "type": "enum",
                "name": "readMatesLengthsIn"
              }
            ],
            "label": "Reads lengths",
            "description": "Equal/Not equal - lengths of names, sequences, qualities for both mates are the same/not the same. \"Not equal\" is safe in all situations.",
            "id": "#readMatesLengthsIn",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--readMatesLengthsIn"
            }
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "-1",
            "type": [
              "null",
              "int"
            ],
            "label": "Reads to map",
            "description": "Number of reads to map from the beginning of the file.",
            "id": "#readMapNumber",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--readMapNumber"
            }
          },
          {
            "sbg:category": "Quantification of Annotations",
            "sbg:toolDefaultValue": "IndelSoftclipSingleend",
            "type": [
              "null",
              {
                "symbols": [
                  "IndelSoftclipSingleend",
                  "Singleend"
                ],
                "type": "enum",
                "name": "quantTranscriptomeBan"
              }
            ],
            "label": "Prohibit alignment type",
            "description": "Prohibit various alignment type. IndelSoftclipSingleend: prohibit indels, soft clipping and single-end alignments - compatible with RSEM; Singleend: prohibit single-end alignments.",
            "id": "#quantTranscriptomeBan",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--quantTranscriptomeBan"
            }
          },
          {
            "sbg:category": "Quantification of Annotations",
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              {
                "symbols": [
                  "TranscriptomeSAM",
                  "GeneCounts"
                ],
                "type": "enum",
                "name": "quantMode"
              }
            ],
            "label": "Quantification mode",
            "description": "Types of quantification requested. 'TranscriptomeSAM' option outputs SAM/BAM alignments to transcriptome into a separate file. With 'GeneCounts' option, STAR will count number of reads per gene while mapping.",
            "id": "#quantMode"
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "SortedByCoordinate",
            "type": [
              "null",
              {
                "symbols": [
                  "Unsorted",
                  "SortedByCoordinate",
                  "Unsorted SortedByCoordinate"
                ],
                "type": "enum",
                "name": "outSortingType"
              }
            ],
            "label": "Output sorting type",
            "description": "Type of output sorting.",
            "id": "#outSortingType"
          },
          {
            "sbg:category": "Output filtering: splice junctions",
            "sbg:toolDefaultValue": "All",
            "type": [
              "null",
              {
                "symbols": [
                  "All",
                  "Unique"
                ],
                "type": "enum",
                "name": "outSJfilterReads"
              }
            ],
            "label": "Collapsed junctions reads",
            "description": "Which reads to consider for collapsed splice junctions output. All: all reads, unique- and multi-mappers; Unique: uniquely mapping reads only.",
            "id": "#outSJfilterReads",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterReads"
            }
          },
          {
            "sbg:category": "Output filtering: splice junctions",
            "sbg:toolDefaultValue": "30 12 12 12",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Min overhang SJ",
            "description": "Minimum overhang length for splice junctions on both sides for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Does not apply to annotated junctions.",
            "id": "#outSJfilterOverhangMin",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterOverhangMin"
            }
          },
          {
            "sbg:category": "Output filtering: splice junctions",
            "sbg:toolDefaultValue": "50000 100000 200000",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Max gap allowed",
            "description": "Maximum gap allowed for junctions supported by 1,2,3...N reads (int >= 0) i.e. by default junctions supported by 1 read can have gaps <=50000b, by 2 reads: <=100000b, by 3 reads: <=200000. By 4 or more reads: any gap <=alignIntronMax. Does not apply to annotated junctions.",
            "id": "#outSJfilterIntronMaxVsReadN",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterIntronMaxVsReadN"
            }
          },
          {
            "sbg:category": "Output filtering: splice junctions",
            "sbg:toolDefaultValue": "10 0 5 10",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Min distance to other donor/acceptor",
            "description": "Minimum allowed distance to other junctions' donor/acceptor for each of the motifs (int >= 0). Does not apply to annotated junctions.",
            "id": "#outSJfilterDistToOtherSJmin",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterDistToOtherSJmin"
            }
          },
          {
            "sbg:category": "Output filtering: splice junctions",
            "sbg:toolDefaultValue": "3 1 1 1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Min unique count",
            "description": "Minimum uniquely mapping read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "id": "#outSJfilterCountUniqueMin",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterCountUniqueMin"
            }
          },
          {
            "sbg:category": "Output filtering: splice junctions",
            "sbg:toolDefaultValue": "3 1 1 1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Min total count",
            "description": "Minimum total (multi-mapping+unique) read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "id": "#outSJfilterCountTotalMin",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterCountTotalMin"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Within"
                ],
                "type": "enum",
                "name": "outSAMunmapped"
              }
            ],
            "label": "Write unmapped in SAM",
            "description": "Output of unmapped reads in the SAM format. None: no output Within: output unmapped reads within the main SAM file (i.e. Aligned.out.sam).",
            "id": "#outSAMunmapped",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMunmapped"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "SAM",
            "type": [
              "null",
              {
                "symbols": [
                  "SAM",
                  "BAM"
                ],
                "type": "enum",
                "name": "outSAMtype"
              }
            ],
            "label": "Output format",
            "description": "Format of output alignments.",
            "id": "#outSAMtype",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  SAM_type = $job.inputs.outSAMtype\n  SORT_type = $job.inputs.outSortingType\n  if (SAM_type && SORT_type) {\n    return \"--outSAMtype \".concat(SAM_type, \" \", SORT_type)\n  }\n}",
                "engine": "#cwl-js-engine"
              }
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "intronMotif"
                ],
                "type": "enum",
                "name": "outSAMstrandField"
              }
            ],
            "label": "Strand field flag",
            "description": "Cufflinks-like strand field flag. None: not used; intronMotif: strand derived from the intron motif. Reads with inconsistent and/or non-canonical introns are filtered out.",
            "id": "#outSAMstrandField",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMstrandField"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "Standard",
            "type": [
              "null",
              {
                "symbols": [
                  "Standard",
                  "Number"
                ],
                "type": "enum",
                "name": "outSAMreadID"
              }
            ],
            "label": "Read ID",
            "description": "Read ID record type. Standard: first word (until space) from the FASTx read ID line, removing /1,/2 from the end; Number: read number (index) in the FASTx file.",
            "id": "#outSAMreadID",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMreadID"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "OneBestScore",
            "type": [
              "null",
              {
                "symbols": [
                  "OneBestScore",
                  "AllBestScore"
                ],
                "type": "enum",
                "name": "outSAMprimaryFlag"
              }
            ],
            "label": "Primary alignments",
            "description": "Which alignments are considered primary - all others will be marked with 0x100 bit in the FLAG. OneBestScore: only one alignment with the best score is primary; AllBestScore: all alignments with the best score are primary.",
            "id": "#outSAMprimaryFlag",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMprimaryFlag"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "Paired",
            "type": [
              "null",
              {
                "symbols": [
                  "Paired",
                  "PairedKeepInputOrder"
                ],
                "type": "enum",
                "name": "outSAMorder"
              }
            ],
            "label": "Sorting in SAM",
            "description": "Type of sorting for the SAM output. Paired: one mate after the other for all paired alignments; PairedKeepInputOrder: one mate after the other for all paired alignments, the order is kept the same as in the input FASTQ files.",
            "id": "#outSAMorder",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMorder"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "Full",
            "type": [
              "null",
              {
                "symbols": [
                  "Full",
                  "NoQS"
                ],
                "type": "enum",
                "name": "outSAMmode"
              }
            ],
            "label": "SAM mode",
            "description": "Mode of SAM output. Full: full SAM output; NoQS: full SAM but without quality scores.",
            "id": "#outSAMmode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMmode"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "255",
            "type": [
              "null",
              "int"
            ],
            "label": "MAPQ value",
            "description": "MAPQ value for unique mappers (0 to 255).",
            "id": "#outSAMmapqUnique",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMmapqUnique"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              "string"
            ],
            "label": "SAM header @PG",
            "description": "Extra @PG (software) line of the SAM header (in addition to STAR).",
            "id": "#outSAMheaderPG",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMheaderPG"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              "string"
            ],
            "label": "SAM header @HD",
            "description": "@HD (header) line of the SAM header.",
            "id": "#outSAMheaderHD",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMheaderHD"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "OR SAM flag",
            "description": "Set specific bits of the SAM FLAG.",
            "id": "#outSAMflagOR",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMflagOR"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "65535",
            "type": [
              "null",
              "int"
            ],
            "label": "AND SAM flag",
            "description": "Set specific bits of the SAM FLAG.",
            "id": "#outSAMflagAND",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMflagAND"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "Standard",
            "type": [
              "null",
              {
                "symbols": [
                  "Standard",
                  "NH",
                  "All",
                  "None"
                ],
                "type": "enum",
                "name": "outSAMattributes"
              }
            ],
            "label": "SAM attributes",
            "description": "Desired SAM attributes, in the order desired for the output SAM. NH: any combination in any order; Standard: NH HI AS nM; All: NH HI AS nM NM MD jM jI; None: no attributes.",
            "id": "#outSAMattributes",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMattributes"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Fastx"
                ],
                "type": "enum",
                "name": "outReadsUnmapped"
              }
            ],
            "label": "Output unmapped reads",
            "description": "Output of unmapped reads (besides SAM). None: no output; Fastx: output in separate fasta/fastq files, Unmapped.out.mate1/2.",
            "id": "#outReadsUnmapped",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outReadsUnmapped"
            }
          },
          {
            "sbg:category": "Output",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Quality conversion",
            "description": "Add this number to the quality score (e.g. to convert from Illumina to Sanger, use -31).",
            "id": "#outQSconversionAdd",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outQSconversionAdd"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "Normal",
            "type": [
              "null",
              {
                "symbols": [
                  "Normal",
                  "BySJout"
                ],
                "type": "enum",
                "name": "outFilterType"
              }
            ],
            "label": "Filtering type",
            "description": "Type of filtering. Normal: standard filtering using only current alignment; BySJout: keep only those reads that contain junctions that passed filtering into SJ.out.tab.",
            "id": "#outFilterType",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterType"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "0.66",
            "type": [
              "null",
              "float"
            ],
            "label": "Min score normalized",
            "description": "'Minimum score' normalized to read length (sum of mates' lengths for paired-end reads).",
            "id": "#outFilterScoreMinOverLread",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterScoreMinOverLread"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Min score",
            "description": "Alignment will be output only if its score is higher than this value.",
            "id": "#outFilterScoreMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterScoreMin"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "1",
            "type": [
              "null",
              "int"
            ],
            "label": "Multimapping score range",
            "description": "The score range below the maximum score for multimapping alignments.",
            "id": "#outFilterMultimapScoreRange",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMultimapScoreRange"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "10",
            "type": [
              "null",
              "int"
            ],
            "label": "Max number of mappings",
            "description": "Read alignments will be output only if the read maps fewer than this value, otherwise no alignments will be output.",
            "id": "#outFilterMultimapNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMultimapNmax"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "1",
            "type": [
              "null",
              "float"
            ],
            "label": "Mismatches to *read* length",
            "description": "Alignment will be output only if its ratio of mismatches to *read* length is less than this value.",
            "id": "#outFilterMismatchNoverReadLmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMismatchNoverReadLmax"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "0.3",
            "type": [
              "null",
              "float"
            ],
            "label": "Mismatches to *mapped* length",
            "description": "Alignment will be output only if its ratio of mismatches to *mapped* length is less than this value.",
            "id": "#outFilterMismatchNoverLmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMismatchNoverLmax"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "10",
            "type": [
              "null",
              "int"
            ],
            "label": "Max number of mismatches",
            "description": "Alignment will be output only if it has fewer mismatches than this value.",
            "id": "#outFilterMismatchNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMismatchNmax"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "0.66",
            "type": [
              "null",
              "float"
            ],
            "label": "Min matched bases normalized",
            "description": "'Minimum matched bases' normalized to read length (sum of mates lengths for paired-end reads).",
            "id": "#outFilterMatchNminOverLread",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMatchNminOverLread"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Min matched bases",
            "description": "Alignment will be output only if the number of matched bases is higher than this value.",
            "id": "#outFilterMatchNmin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMatchNmin"
            }
          },
          {
            "sbg:category": "Output filtering",
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "RemoveNoncanonical",
                  "RemoveNoncanonicalUnannotated"
                ],
                "type": "enum",
                "name": "outFilterIntronMotifs"
              }
            ],
            "label": "Motifs filtering",
            "description": "Filter alignment using their motifs. None: no filtering; RemoveNoncanonical: filter out alignments that contain non-canonical junctions; RemoveNoncanonicalUnannotated: filter out alignments that contain non-canonical unannotated junctions when using annotated splice junctions database. The annotated non-canonical junctions will be kept.",
            "id": "#outFilterIntronMotifs",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterIntronMotifs"
            }
          },
          {
            "sbg:category": "Limits",
            "sbg:toolDefaultValue": "1000000",
            "type": [
              "null",
              "int"
            ],
            "label": "Max insert junctions",
            "description": "Maximum number of junction to be inserted to the genome on the fly at the mapping stage, including those from annotations and those detected in the 1st step of the 2-pass run.",
            "id": "#limitSjdbInsertNsj",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitSjdbInsertNsj"
            }
          },
          {
            "sbg:category": "Limits",
            "sbg:toolDefaultValue": "1000",
            "type": [
              "null",
              "int"
            ],
            "label": "Junctions max number",
            "description": "Max number of junctions for one read (including all multi-mappers).",
            "id": "#limitOutSJoneRead",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitOutSJoneRead"
            }
          },
          {
            "sbg:category": "Limits",
            "sbg:toolDefaultValue": "1000000",
            "type": [
              "null",
              "int"
            ],
            "label": "Collapsed junctions max number",
            "description": "Max number of collapsed junctions.",
            "id": "#limitOutSJcollapsed",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitOutSJcollapsed"
            }
          },
          {
            "sbg:category": "Limits",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Limit BAM sorting memory",
            "description": "Maximum available RAM for sorting BAM. If set to 0, it will be set to the genome index size.",
            "id": "#limitBAMsortRAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitBAMsortRAM"
            }
          },
          {
            "sbg:category": "Basic",
            "sbg:toolDefaultValue": "genomeDir",
            "type": [
              "null",
              "string"
            ],
            "label": "Genome dir name",
            "description": "Name of the directory which contains genome files (when genome.tar is uncompressed).",
            "id": "#genomeDirName",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 0,
              "prefix": "--genomeDir",
              "valueFrom": {
                "class": "Expression",
                "script": "$job.inputs.genomeDirName || \"genomeDir\"",
                "engine": "#cwl-js-engine"
              }
            }
          },
          {
            "sbg:category": "Basic",
            "type": [
              "File"
            ],
            "label": "Genome files",
            "description": "Genome files created using STAR Genome Generate.",
            "id": "#genome",
            "sbg:fileTypes": "TAR",
            "required": true
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Clip 5p bases",
            "description": "Number of bases to clip from 5p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip5pNbases",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--clip5pNbases"
            }
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Clip 3p bases",
            "description": "Number of bases to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pNbases",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--clip3pNbases"
            }
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "label": "Clip 3p after adapter seq.",
            "description": "Number of bases to clip from 3p of each mate after the adapter clipping. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pAfterAdapterNbases",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--clip3pAfterAdapterNbases"
            }
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              {
                "type": "array",
                "items": "string"
              }
            ],
            "label": "Clip 3p adapter sequence",
            "description": "Adapter sequence to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pAdapterSeq",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--clip3pAdapterSeq"
            }
          },
          {
            "sbg:category": "Read parameters",
            "sbg:toolDefaultValue": "0.1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "float"
              }
            ],
            "label": "Max mismatches proportions",
            "description": "Max proportion of mismatches for 3p adapter clipping for each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pAdapterMMp",
            "inputBinding": {
              "itemSeparator": " ",
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--clip3pAdapterMMp"
            }
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "15",
            "type": [
              "null",
              "int"
            ],
            "label": "Min segment length",
            "description": "Minimum length of chimeric segment length, if =0, no chimeric output (int>=0).",
            "id": "#chimSegmentMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimSegmentMin"
            }
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "10",
            "type": [
              "null",
              "int"
            ],
            "label": "Min separation score",
            "description": "Minimum difference (separation) between the best chimeric score and the next one (int>=0).",
            "id": "#chimScoreSeparation",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreSeparation"
            }
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Min total score",
            "description": "Minimum total (summed) score of the chimeric segments (int>=0).",
            "id": "#chimScoreMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreMin"
            }
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "-1",
            "type": [
              "null",
              "int"
            ],
            "label": "Non-GT/AG penalty",
            "description": "Penalty for a non-GT/AG chimeric junction.",
            "id": "#chimScoreJunctionNonGTAG",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreJunctionNonGTAG"
            }
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "20",
            "type": [
              "null",
              "int"
            ],
            "label": "Max drop score",
            "description": "Max drop (difference) of chimeric score (the sum of scores of all chimeric segements) from the read length (int>=0).",
            "id": "#chimScoreDropMax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreDropMax"
            }
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "SeparateSAMold",
            "type": [
              "null",
              {
                "symbols": [
                  "SeparateSAMold",
                  "Within"
                ],
                "type": "enum",
                "name": "chimOutType"
              }
            ],
            "label": "Chimeric output type",
            "description": "Type of chimeric output. SeparateSAMold: output old SAM into separate Chimeric.out.sam file; Within: output into main aligned SAM/BAM files.",
            "id": "#chimOutType"
          },
          {
            "sbg:category": "Chimeric Alignments",
            "sbg:toolDefaultValue": "20",
            "type": [
              "null",
              "int"
            ],
            "label": "Min junction overhang",
            "description": "Minimum overhang for a chimeric junction (int>=0).",
            "id": "#chimJunctionOverhangMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimJunctionOverhangMin"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "10000",
            "type": [
              "null",
              "float"
            ],
            "label": "Max windows per read",
            "description": "Max number of windows per read (int>0).",
            "id": "#alignWindowsPerReadNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignWindowsPerReadNmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "100",
            "type": [
              "null",
              "int"
            ],
            "label": "Max transcripts per window",
            "description": "Max number of transcripts per window (int>0).",
            "id": "#alignTranscriptsPerWindowNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignTranscriptsPerWindowNmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "10000",
            "type": [
              "null",
              "int"
            ],
            "label": "Max transcripts per read",
            "description": "Max number of different alignments per read to consider (int>0).",
            "id": "#alignTranscriptsPerReadNmax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignTranscriptsPerReadNmax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "0.66",
            "type": [
              "null",
              "float"
            ],
            "label": "Min mapped length normalized",
            "description": "alignSplicedMateMapLmin normalized to mate length (float>0).",
            "id": "#alignSplicedMateMapLminOverLmate",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSplicedMateMapLminOverLmate"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Min mapped length",
            "description": "Minimum mapped length for a read mate that is spliced (int>0).",
            "id": "#alignSplicedMateMapLmin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSplicedMateMapLmin"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "Yes",
            "type": [
              "null",
              {
                "symbols": [
                  "Yes",
                  "No"
                ],
                "type": "enum",
                "name": "alignSoftClipAtReferenceEnds"
              }
            ],
            "label": "Soft clipping",
            "description": "Option which allows soft clipping of alignments at the reference (chromosome) ends. Can be disabled for compatibility with Cufflinks/Cuffmerge. Yes: Enables soft clipping; No: Disables soft clipping.",
            "id": "#alignSoftClipAtReferenceEnds",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSoftClipAtReferenceEnds"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "5",
            "type": [
              "null",
              "int"
            ],
            "label": "Min overhang",
            "description": "Minimum overhang (i.e. block size) for spliced alignments (int>0).",
            "id": "#alignSJoverhangMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSJoverhangMin"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "3",
            "type": [
              "null",
              "int"
            ],
            "label": "Min overhang: annotated",
            "description": "Minimum overhang (i.e. block size) for annotated (sjdb) spliced alignments (int>0).",
            "id": "#alignSJDBoverhangMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSJDBoverhangMin"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Max mates gap",
            "description": "Maximum gap between two mates, if 0, max intron gap will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "id": "#alignMatesGapMax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignMatesGapMax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "21",
            "type": [
              "null",
              "int"
            ],
            "label": "Min intron size",
            "description": "Minimum intron size: genomic gap is considered intron if its length >= alignIntronMin, otherwise it is considered Deletion (int>=0).",
            "id": "#alignIntronMin",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignIntronMin"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "0",
            "type": [
              "null",
              "int"
            ],
            "label": "Max intron size",
            "description": "Maximum intron size, if 0, max intron size will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "id": "#alignIntronMax",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignIntronMax"
            }
          },
          {
            "sbg:category": "Alignments and Seeding",
            "sbg:toolDefaultValue": "Local",
            "type": [
              "null",
              {
                "symbols": [
                  "Local",
                  "EndToEnd"
                ],
                "type": "enum",
                "name": "alignEndsType"
              }
            ],
            "label": "Alignment type",
            "description": "Type of read ends alignment. Local: standard local alignment with soft-clipping allowed. EndToEnd: force end to end read alignment, do not soft-clip.",
            "id": "#alignEndsType",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignEndsType"
            }
          }
        ],
        "label": "STAR",
        "sbg:project": "bix-demo/star-2-4-2a-demo",
        "y": 323,
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 15
          },
          "inputs": {
            "alignWindowsPerReadNmax": 0,
            "outSAMheaderPG": "outSAMheaderPG",
            "GENOME_DIR_NAME": "",
            "outFilterMatchNminOverLread": 0,
            "rg_platform_unit_id": "rg_platform_unit",
            "alignTranscriptsPerReadNmax": 0,
            "readMapNumber": 0,
            "alignSplicedMateMapLminOverLmate": 0,
            "alignMatesGapMax": 0,
            "outFilterMultimapNmax": 0,
            "clip5pNbases": [
              0
            ],
            "outSAMstrandField": "None",
            "readMatesLengthsIn": "NotEqual",
            "outSAMattributes": "Standard",
            "seedMultimapNmax": 0,
            "rg_mfl": "rg_mfl",
            "chimSegmentMin": 0,
            "winAnchorDistNbins": 0,
            "outSortingType": "SortedByCoordinate",
            "outFilterMultimapScoreRange": 0,
            "sjdbInsertSave": "Basic",
            "clip3pAfterAdapterNbases": [
              0
            ],
            "scoreDelBase": 0,
            "outFilterMatchNmin": 0,
            "twopass1readsN": 0,
            "outSAMunmapped": "None",
            "genome": {
              "size": 0,
              "secondaryFiles": [],
              "class": "File",
              "path": "genome.ext"
            },
            "sjdbGTFtagExonParentTranscript": "",
            "limitBAMsortRAM": 0,
            "alignEndsType": "Local",
            "seedNoneLociPerWindow": 0,
            "rg_sample_id": "rg_sample",
            "sjdbGTFtagExonParentGene": "",
            "chimScoreMin": 0,
            "outSJfilterIntronMaxVsReadN": [
              0
            ],
            "twopassMode": "Basic",
            "alignSplicedMateMapLmin": 0,
            "outSJfilterReads": "All",
            "outSAMprimaryFlag": "OneBestScore",
            "outSJfilterCountTotalMin": [
              3,
              1,
              1,
              1
            ],
            "outSAMorder": "Paired",
            "outSAMflagAND": 0,
            "chimScoreSeparation": 0,
            "alignSJoverhangMin": 0,
            "outFilterScoreMin": 0,
            "seedSearchStartLmax": 0,
            "scoreGapGCAG": 0,
            "scoreGenomicLengthLog2scale": 0,
            "outFilterIntronMotifs": "None",
            "outFilterMismatchNmax": 0,
            "reads": [
              {
                "size": 0,
                "secondaryFiles": [],
                "class": "File",
                "metadata": {
                  "format": "fastq",
                  "paired_end": "1",
                  "seq_center": "illumina"
                },
                "path": "/test-data/mate_1.fastq.bz2"
              }
            ],
            "scoreGap": 0,
            "outSJfilterOverhangMin": [
              30,
              12,
              12,
              12
            ],
            "outSAMflagOR": 0,
            "outSAMmode": "Full",
            "rg_library_id": "",
            "chimScoreJunctionNonGTAG": 0,
            "scoreInsOpen": 0,
            "clip3pAdapterSeq": [
              "clip3pAdapterSeq"
            ],
            "chimScoreDropMax": 0,
            "outFilterType": "Normal",
            "scoreGapATAC": 0,
            "rg_platform": "Ion Torrent PGM",
            "clip3pAdapterMMp": [
              0
            ],
            "sjdbGTFfeatureExon": "",
            "outQSconversionAdd": 0,
            "quantMode": "TranscriptomeSAM",
            "alignIntronMin": 0,
            "scoreInsBase": 0,
            "scoreGapNoncan": 0,
            "seedSearchLmax": 0,
            "outSJfilterDistToOtherSJmin": [
              0
            ],
            "outFilterScoreMinOverLread": 0,
            "alignSJDBoverhangMin": 0,
            "limitOutSJcollapsed": 0,
            "winAnchorMultimapNmax": 0,
            "outFilterMismatchNoverLmax": 0,
            "rg_seq_center": "",
            "outSAMheaderHD": "outSAMheaderHD",
            "chimOutType": "Within",
            "quantTranscriptomeBan": "IndelSoftclipSingleend",
            "limitOutSJoneRead": 0,
            "alignTranscriptsPerWindowNmax": 0,
            "sjdbOverhang": null,
            "outReadsUnmapped": "Fastx",
            "scoreStitchSJshift": 0,
            "seedPerWindowNmax": 0,
            "outSJfilterCountUniqueMin": [
              3,
              1,
              1,
              1
            ],
            "scoreDelOpen": 0,
            "sjdbGTFfile": [
              {
                "path": "/demo/test-data/chr20.gtf"
              }
            ],
            "clip3pNbases": [
              0,
              3
            ],
            "winBinNbits": 0,
            "sjdbScore": null,
            "seedSearchStartLmaxOverLread": 0,
            "alignIntronMax": 0,
            "seedPerReadNmax": 0,
            "outFilterMismatchNoverReadLmax": 0,
            "winFlankNbins": 0,
            "sjdbGTFchrPrefix": "chrPrefix",
            "alignSoftClipAtReferenceEnds": "Yes",
            "outSAMreadID": "Standard",
            "outSAMtype": "BAM",
            "chimJunctionOverhangMin": 0,
            "limitSjdbInsertNsj": 0,
            "outSAMmapqUnique": 0
          }
        },
        "sbg:contributors": [
          "ana_d",
          "bix-demo",
          "uros_sipetic"
        ],
        "sbg:createdOn": 1450911471,
        "sbg:validationErrors": [],
        "outputs": [
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "label": "Unmapped reads",
            "description": "Output of unmapped reads.",
            "id": "#unmapped_reads",
            "sbg:fileTypes": "FASTQ",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Unmapped.out*",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Transcriptome alignments",
            "description": "Alignments translated into transcript coordinates.",
            "id": "#transcriptome_aligned_reads",
            "sbg:fileTypes": "BAM",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Transcriptome*",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Splice junctions",
            "description": "High confidence collapsed splice junctions in tab-delimited format. Only junctions supported by uniquely mapping reads are reported.",
            "id": "#splice_junctions",
            "sbg:fileTypes": "TAB",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*SJ.out.tab",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Reads per gene",
            "description": "File with number of reads per gene. A read is counted if it overlaps (1nt or more) one and only one gene.",
            "id": "#reads_per_gene",
            "sbg:fileTypes": "TAB",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*ReadsPerGene*",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "label": "Log files",
            "description": "Log files produced during alignment.",
            "id": "#log_files",
            "sbg:fileTypes": "OUT",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Log*.out",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Intermediate genome files",
            "description": "Archive with genome files produced when annotations are included on the fly (in the mapping step).",
            "id": "#intermediate_genome",
            "sbg:fileTypes": "TAR",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*_STARgenome.tar",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Chimeric junctions",
            "description": "If chimSegmentMin in 'Chimeric Alignments' section is set to 0, 'Chimeric Junctions' won't be output.",
            "id": "#chimeric_junctions",
            "sbg:fileTypes": "JUNCTION",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Chimeric.out.junction",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Chimeric alignments",
            "description": "Aligned Chimeric sequences SAM - if chimSegmentMin = 0, no Chimeric Alignment SAM and Chimeric Junctions outputs.",
            "id": "#chimeric_alignments",
            "sbg:fileTypes": "SAM",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*.Chimeric.out.sam",
              "sbg:metadata": {}
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "label": "Aligned SAM/BAM",
            "description": "Aligned sequence in SAM/BAM format.",
            "id": "#aligned_reads",
            "sbg:fileTypes": "SAM, BAM",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.outSortingType == 'SortedByCoordinate') {\n    sort_name = '.sortedByCoord'\n  }\n  else {\n    sort_name = ''\n  }\n  if ($job.inputs.outSAMtype == 'BAM') {\n    sam_name = \"*.Aligned\".concat( sort_name, '.out.bam')\n  }\n  else {\n    sam_name = \"*.Aligned.out.sam\"\n  }\n  return sam_name\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {}
            }
          }
        ],
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:latestRevision": 4,
        "sbg:modifiedBy": "ana_d",
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "stdin": "",
        "sbg:toolkit": "STAR",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911471,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911473,
            "sbg:revision": 1
          },
          {
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911475,
            "sbg:revision": 2
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1462878528,
            "sbg:revision": 3
          },
          {
            "sbg:modifiedBy": "ana_d",
            "sbg:modifiedOn": 1462889222,
            "sbg:revision": 4
          }
        ],
        "id": "sevenbridges/public-apps/star/4",
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  file = [].concat($job.inputs.reads)[0].path\n  extension = /(?:\\.([^.]+))?$/.exec(file)[1]\n  if (extension == \"gz\") {\n    return \"--readFilesCommand zcat\"\n  } else if (extension == \"bz2\") {\n    return \"--readFilesCommand bzcat\"\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\t\n  var sjFormat = \"False\"\n  var gtfgffFormat = \"False\"\n  var list = $job.inputs.sjdbGTFfile\n  var paths_list = []\n  var joined_paths = \"\"\n  \n  if (list) {\n    list.forEach(function(f){return paths_list.push(f.path)})\n    joined_paths = paths_list.join(\" \")\n\n\n    paths_list.forEach(function(f){\n      ext = f.replace(/^.*\\./, '')\n      if (ext == \"gff\" || ext == \"gtf\") {\n        gtfgffFormat = \"True\"\n        return gtfgffFormat\n      }\n      if (ext == \"txt\") {\n        sjFormat = \"True\"\n        return sjFormat\n      }\n    })\n\n    if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave != \"None\") {\n      if (sjFormat == \"True\") {\n        return \"--sjdbFileChrStartEnd \".concat(joined_paths)\n      }\n      else if (gtfgffFormat == \"True\") {\n        return \"--sjdbGTFfile \".concat(joined_paths)\n      }\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  a = b = c = d = e = f = g = []\n  if ($job.inputs.sjdbGTFchrPrefix) {\n    a = [\"--sjdbGTFchrPrefix\", $job.inputs.sjdbGTFchrPrefix]\n  }\n  if ($job.inputs.sjdbGTFfeatureExon) {\n    b = [\"--sjdbGTFfeatureExon\", $job.inputs.sjdbGTFfeatureExon]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentTranscript) {\n    c = [\"--sjdbGTFtagExonParentTranscript\", $job.inputs.sjdbGTFtagExonParentTranscript]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentGene) {\n    d = [\"--sjdbGTFtagExonParentGene\", $job.inputs.sjdbGTFtagExonParentGene]\n  }\n  if ($job.inputs.sjdbOverhang) {\n    e = [\"--sjdbOverhang\", $job.inputs.sjdbOverhang]\n  }\n  if ($job.inputs.sjdbScore) {\n    f = [\"--sjdbScore\", $job.inputs.sjdbScore]\n  }\n  if ($job.inputs.sjdbInsertSave) {\n    g = [\"--sjdbInsertSave\", $job.inputs.sjdbInsertSave]\n  }\n  \n  \n  \n  if ($job.inputs.sjdbInsertSave != \"None\" && $job.inputs.sjdbGTFfile) {\n    new_list = a.concat(b, c, d, e, f, g)\n    return new_list.join(\" \")\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if ($job.inputs.twopassMode == \"Basic\") {\n    return \"--twopass1readsN \".concat($job.inputs.twopass1readsN)\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if ($job.inputs.chimOutType == \"Within\") {\n    return \"--chimOutType \".concat(\"Within\", $job.inputs.outSAMtype)\n  }\n  else {\n    return \"--chimOutType SeparateSAMold\"\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var param_list = []\n  \n  function add_param(key, value){\n    if (value == \"\") {\n      return\n    }\n    else {\n      return param_list.push(key.concat(\":\", value))\n    }\n  }\n  \n  add_param('ID', \"1\")\n  if ($job.inputs.rg_seq_center) {\n    add_param('CN', $job.inputs.rg_seq_center)\n  } else if ([].concat($job.inputs.reads)[0].metadata.seq_center) {\n    add_param('CN', [].concat($job.inputs.reads)[0].metadata.seq_center)\n  }\n  if ($job.inputs.rg_library_id) {\n    add_param('LB', $job.inputs.rg_library_id)\n  } else if ([].concat($job.inputs.reads)[0].metadata.library_id) {\n    add_param('LB', [].concat($job.inputs.reads)[0].metadata.library_id)\n  }\n  if ($job.inputs.rg_mfl) {\n    add_param('PI', $job.inputs.rg_mfl)\n  } else if ([].concat($job.inputs.reads)[0].metadata.median_fragment_length) {\n    add_param('PI', [].concat($job.inputs.reads)[0].metadata.median_fragment_length)\n  }\n  if ($job.inputs.rg_platform) {\n    add_param('PL', $job.inputs.rg_platform.replace(/ /g,\"_\"))\n  } else if ([].concat($job.inputs.reads)[0].metadata.platform) {\n    add_param('PL', [].concat($job.inputs.reads)[0].metadata.platform.replace(/ /g,\"_\"))\n  }\n  if ($job.inputs.rg_platform_unit_id) {\n    add_param('PU', $job.inputs.rg_platform_unit_id)\n  } else if ([].concat($job.inputs.reads)[0].metadata.platform_unit_id) {\n    add_param('PU', [].concat($job.inputs.reads)[0].metadata.platform_unit_id)\n  }\n  if ($job.inputs.rg_sample_id) {\n    add_param('SM', $job.inputs.rg_sample_id)\n  } else if ([].concat($job.inputs.reads)[0].metadata.sample_id) {\n    add_param('SM', [].concat($job.inputs.reads)[0].metadata.sample_id)\n  }\n  return \"--outSAMattrRGline \".concat(param_list.join(\" \"))\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if ($job.inputs.sjdbGTFfile && $job.inputs.quantMode) {\n    return \"--quantMode \".concat($job.inputs.quantMode)\n  }\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  intermediate = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\"._STARgenome\")\n  source = \"./\".concat(intermediate)\n  destination = intermediate.concat(\".tar\")\n  if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave && $job.inputs.sjdbInsertSave != \"None\") {\n    return \"&& tar -vcf \".concat(destination, \" \", source)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "position": 100
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\")\n}",
              "engine": "#cwl-js-engine"
            },
            "prefix": "--outFileNamePrefix"
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  mate1 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\".Unmapped.out.mate1\")\n  mate2 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\".Unmapped.out.mate2\")\n  mate1fq = mate1.concat(\".fastq\")\n  mate2fq = mate2.concat(\".fastq\")\n  if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq, \" && mv \", mate2, \" \", mate2fq)\n  }\n  else if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length == 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "position": 101
          }
        ],
        "temporaryFailCodes": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false
      },
      "inputs": [
        {
          "id": "#STAR.winFlankNbins"
        },
        {
          "id": "#STAR.winBinNbits"
        },
        {
          "id": "#STAR.winAnchorMultimapNmax",
          "source": [
            "#winAnchorMultimapNmax"
          ]
        },
        {
          "id": "#STAR.winAnchorDistNbins",
          "source": [
            "#winAnchorDistNbins"
          ]
        },
        {
          "id": "#STAR.twopassMode"
        },
        {
          "id": "#STAR.twopass1readsN"
        },
        {
          "id": "#STAR.sjdbScore"
        },
        {
          "id": "#STAR.sjdbOverhang",
          "default": 100
        },
        {
          "id": "#STAR.sjdbInsertSave"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentTranscript"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentGene"
        },
        {
          "id": "#STAR.sjdbGTFfile",
          "source": [
            "#sjdbGTFfile"
          ]
        },
        {
          "id": "#STAR.sjdbGTFfeatureExon"
        },
        {
          "id": "#STAR.sjdbGTFchrPrefix"
        },
        {
          "id": "#STAR.seedSearchStartLmaxOverLread"
        },
        {
          "id": "#STAR.seedSearchStartLmax"
        },
        {
          "id": "#STAR.seedSearchLmax"
        },
        {
          "id": "#STAR.seedPerWindowNmax"
        },
        {
          "id": "#STAR.seedPerReadNmax"
        },
        {
          "id": "#STAR.seedNoneLociPerWindow"
        },
        {
          "id": "#STAR.seedMultimapNmax"
        },
        {
          "id": "#STAR.scoreStitchSJshift"
        },
        {
          "id": "#STAR.scoreInsOpen"
        },
        {
          "id": "#STAR.scoreInsBase"
        },
        {
          "id": "#STAR.scoreGenomicLengthLog2scale"
        },
        {
          "id": "#STAR.scoreGapNoncan"
        },
        {
          "id": "#STAR.scoreGapGCAG"
        },
        {
          "id": "#STAR.scoreGapATAC"
        },
        {
          "id": "#STAR.scoreGap"
        },
        {
          "id": "#STAR.scoreDelOpen"
        },
        {
          "id": "#STAR.scoreDelBase"
        },
        {
          "id": "#STAR.rg_seq_center"
        },
        {
          "id": "#STAR.rg_sample_id"
        },
        {
          "id": "#STAR.rg_platform_unit_id"
        },
        {
          "id": "#STAR.rg_platform"
        },
        {
          "id": "#STAR.rg_mfl"
        },
        {
          "id": "#STAR.rg_library_id"
        },
        {
          "id": "#STAR.reads",
          "source": [
            "#SBG_FASTQ_Quality_Detector.result"
          ]
        },
        {
          "id": "#STAR.readMatesLengthsIn"
        },
        {
          "id": "#STAR.readMapNumber"
        },
        {
          "id": "#STAR.quantTranscriptomeBan"
        },
        {
          "id": "#STAR.quantMode",
          "default": "TranscriptomeSAM"
        },
        {
          "id": "#STAR.outSortingType",
          "default": "SortedByCoordinate"
        },
        {
          "id": "#STAR.outSJfilterReads"
        },
        {
          "id": "#STAR.outSJfilterOverhangMin"
        },
        {
          "id": "#STAR.outSJfilterIntronMaxVsReadN"
        },
        {
          "id": "#STAR.outSJfilterDistToOtherSJmin"
        },
        {
          "id": "#STAR.outSJfilterCountUniqueMin"
        },
        {
          "id": "#STAR.outSJfilterCountTotalMin"
        },
        {
          "id": "#STAR.outSAMunmapped"
        },
        {
          "id": "#STAR.outSAMtype",
          "default": "BAM"
        },
        {
          "id": "#STAR.outSAMstrandField"
        },
        {
          "id": "#STAR.outSAMreadID"
        },
        {
          "id": "#STAR.outSAMprimaryFlag"
        },
        {
          "id": "#STAR.outSAMorder"
        },
        {
          "id": "#STAR.outSAMmode"
        },
        {
          "id": "#STAR.outSAMmapqUnique"
        },
        {
          "id": "#STAR.outSAMheaderPG"
        },
        {
          "id": "#STAR.outSAMheaderHD"
        },
        {
          "id": "#STAR.outSAMflagOR"
        },
        {
          "id": "#STAR.outSAMflagAND"
        },
        {
          "id": "#STAR.outSAMattributes"
        },
        {
          "id": "#STAR.outReadsUnmapped",
          "default": "Fastx"
        },
        {
          "id": "#STAR.outQSconversionAdd"
        },
        {
          "id": "#STAR.outFilterType"
        },
        {
          "id": "#STAR.outFilterScoreMinOverLread"
        },
        {
          "id": "#STAR.outFilterScoreMin"
        },
        {
          "id": "#STAR.outFilterMultimapScoreRange"
        },
        {
          "id": "#STAR.outFilterMultimapNmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverReadLmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverLmax"
        },
        {
          "id": "#STAR.outFilterMismatchNmax"
        },
        {
          "id": "#STAR.outFilterMatchNminOverLread"
        },
        {
          "id": "#STAR.outFilterMatchNmin"
        },
        {
          "id": "#STAR.outFilterIntronMotifs"
        },
        {
          "id": "#STAR.limitSjdbInsertNsj"
        },
        {
          "id": "#STAR.limitOutSJoneRead"
        },
        {
          "id": "#STAR.limitOutSJcollapsed"
        },
        {
          "id": "#STAR.limitBAMsortRAM"
        },
        {
          "id": "#STAR.genomeDirName"
        },
        {
          "id": "#STAR.genome",
          "source": [
            "#STAR_Genome_Generate.genome"
          ]
        },
        {
          "id": "#STAR.clip5pNbases"
        },
        {
          "id": "#STAR.clip3pNbases"
        },
        {
          "id": "#STAR.clip3pAfterAdapterNbases"
        },
        {
          "id": "#STAR.clip3pAdapterSeq"
        },
        {
          "id": "#STAR.clip3pAdapterMMp"
        },
        {
          "id": "#STAR.chimSegmentMin"
        },
        {
          "id": "#STAR.chimScoreSeparation"
        },
        {
          "id": "#STAR.chimScoreMin"
        },
        {
          "id": "#STAR.chimScoreJunctionNonGTAG"
        },
        {
          "id": "#STAR.chimScoreDropMax"
        },
        {
          "id": "#STAR.chimOutType"
        },
        {
          "id": "#STAR.chimJunctionOverhangMin"
        },
        {
          "id": "#STAR.alignWindowsPerReadNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerWindowNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerReadNmax"
        },
        {
          "id": "#STAR.alignSplicedMateMapLminOverLmate"
        },
        {
          "id": "#STAR.alignSplicedMateMapLmin"
        },
        {
          "id": "#STAR.alignSoftClipAtReferenceEnds"
        },
        {
          "id": "#STAR.alignSJoverhangMin"
        },
        {
          "id": "#STAR.alignSJDBoverhangMin"
        },
        {
          "id": "#STAR.alignMatesGapMax"
        },
        {
          "id": "#STAR.alignIntronMin"
        },
        {
          "id": "#STAR.alignIntronMax"
        },
        {
          "id": "#STAR.alignEndsType"
        }
      ],
      "outputs": [
        {
          "id": "#STAR.unmapped_reads"
        },
        {
          "id": "#STAR.transcriptome_aligned_reads"
        },
        {
          "id": "#STAR.splice_junctions"
        },
        {
          "id": "#STAR.reads_per_gene"
        },
        {
          "id": "#STAR.log_files"
        },
        {
          "id": "#STAR.intermediate_genome"
        },
        {
          "id": "#STAR.chimeric_junctions"
        },
        {
          "id": "#STAR.chimeric_alignments"
        },
        {
          "id": "#STAR.aligned_reads"
        }
      ],
      "sbg:x": 623.9999999999999,
      "sbg:y": 323
    }
  ],
  "requirements": [],
  "inputs": [
    {
      "id": "#sjdbGTFfile",
      "sbg:x": 160.49997586011762,
      "type": [
        "null",
        {
          "type": "array",
          "items": "File"
        }
      ],
      "label": "sjdbGTFfile",
      "sbg:y": 195.08331063389656
    },
    {
      "sbg:includeInPorts": true,
      "sbg:x": 164.24999140203002,
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "label": "fastq",
      "sbg:y": 323.74995018542,
      "id": "#fastq"
    },
    {
      "id": "#genomeFastaFiles",
      "sbg:x": 167.749960079791,
      "type": [
        "File"
      ],
      "label": "genomeFastaFiles",
      "sbg:y": 469.9999105781354
    },
    {
      "sbg:category": "Splice junctions db parameters",
      "sbg:toolDefaultValue": "transcript_id",
      "type": [
        "null",
        "string"
      ],
      "label": "Exons' parents name",
      "description": "Tag name to be used as exons' transcript-parents.",
      "id": "#sjdbGTFtagExonParentTranscript"
    },
    {
      "sbg:category": "Splice junctions db parameters",
      "sbg:toolDefaultValue": "gene_id",
      "type": [
        "null",
        "string"
      ],
      "label": "Gene name",
      "description": "Tag name to be used as exons' gene-parents.",
      "id": "#sjdbGTFtagExonParentGene"
    },
    {
      "sbg:category": "Windows, Anchors, Binning",
      "sbg:toolDefaultValue": "50",
      "type": [
        "null",
        "int"
      ],
      "label": "Max loci anchors",
      "description": "Max number of loci anchors are allowed to map to (int>0).",
      "id": "#winAnchorMultimapNmax"
    },
    {
      "sbg:category": "Windows, Anchors, Binning",
      "sbg:toolDefaultValue": "9",
      "type": [
        "null",
        "int"
      ],
      "label": "Max bins between anchors",
      "description": "Max number of bins between two anchors that allows aggregation of anchors into one window (int>0).",
      "id": "#winAnchorDistNbins"
    }
  ],
  "outputs": [
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        {
          "type": "array",
          "items": "File"
        }
      ],
      "required": false,
      "label": "unmapped_reads",
      "sbg:y": 159.58330912391222,
      "sbg:x": 766.2497863074045,
      "id": "#unmapped_reads",
      "source": [
        "#STAR.unmapped_reads"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "transcriptome_aligned_reads",
      "sbg:y": 86.58332158128358,
      "sbg:x": 1118.9998003244302,
      "id": "#transcriptome_aligned_reads",
      "source": [
        "#STAR.transcriptome_aligned_reads"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "splice_junctions",
      "sbg:y": 167.49997603893155,
      "sbg:x": 1282.3330177465928,
      "id": "#splice_junctions",
      "source": [
        "#STAR.splice_junctions"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "reads_per_gene",
      "sbg:y": 245.74996398885858,
      "sbg:x": 1394.416355699286,
      "id": "#reads_per_gene",
      "source": [
        "#STAR.reads_per_gene"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        {
          "type": "array",
          "items": "File"
        }
      ],
      "required": false,
      "label": "log_files",
      "sbg:y": 322.9999517997081,
      "sbg:x": 1505.0830268959055,
      "id": "#log_files",
      "source": [
        "#STAR.log_files"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "chimeric_junctions",
      "sbg:y": 446.7499567170913,
      "sbg:x": 1278.7498061756194,
      "id": "#chimeric_junctions",
      "source": [
        "#STAR.chimeric_junctions"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "intermediate_genome",
      "sbg:y": 386.0832876066342,
      "sbg:x": 1408.9164783457816,
      "id": "#intermediate_genome",
      "source": [
        "#STAR.intermediate_genome"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "chimeric_alignments",
      "sbg:y": 503.2499285439613,
      "sbg:x": 1147.5831347604494,
      "id": "#chimeric_alignments",
      "source": [
        "#STAR.chimeric_alignments"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "sorted_bam",
      "sbg:y": 557.2498435974195,
      "sbg:x": 934.2498227655963,
      "id": "#sorted_bam",
      "source": [
        "#Picard_SortSam.sorted_bam"
      ]
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "required": false,
      "label": "result",
      "sbg:y": 644.99998979436,
      "sbg:x": 1431.6666547523607,
      "id": "#result",
      "source": [
        "#SBG_FASTQ_Quality_Detector.result"
      ]
    }
  ],
  "sbg:canvas_zoom": 0.5999999999999996,
  "sbg:contributors": [
    "tengfei"
  ],
  "sbg:createdBy": "tengfei",
  "sbg:toolAuthor": "Seven Bridges Genomics",
  "sbg:modifiedOn": 1463601974,
  "sbg:createdOn": 1463601910,
  "sbg:project": "tengfei/quickstart",
  "sbg:image_url": null,
  "sbg:revision": 2,
  "sbg:latestRevision": 2,
  "sbg:id": "tengfei/quickstart/rna-seq-alignment-star-demo/2",
  "sbg:toolkitVersion": "2.4.2a",
  "sbg:canvas_y": -16,
  "sbg:validationErrors": [],
  "sbg:categories": [
    "Alignment",
    "RNA"
  ],
  "sbg:modifiedBy": "tengfei",
  "sbg:canvas_x": -41,
  "sbg:toolkit": "STAR",
  "sbg:revisionsInfo": [
    {
      "sbg:modifiedBy": "tengfei",
      "sbg:modifiedOn": 1463601910,
      "sbg:revision": 0
    },
    {
      "sbg:modifiedBy": "tengfei",
      "sbg:modifiedOn": 1463601952,
      "sbg:revision": 1
    },
    {
      "sbg:modifiedBy": "tengfei",
      "sbg:modifiedOn": 1463601974,
      "sbg:revision": 2
    }
  ],
  "sbg:license": "Apache License 2.0",
  "sbg:sbgMaintained": false,
  "id": "tengfei/quickstart/rna-seq-alignment-star-demo/2",
  "label": "RNA-seq Alignment - STAR",
  "description": "Alignment to a reference genome and transcriptome presents the first step of RNA-Seq analysis. This pipeline uses STAR, an ultrafast RNA-seq aligner capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs.\n\nSTAR accepts one file per sample (or two files for paired-end data).  \nSplice junction annotations can optionally be collected from splice junction databases. Set the \"Overhang length\" parameter to a value larger than zero in order to use splice junction databases. For constant read length, this value should (ideally) be equal to mate length decreased by 1; for long reads with non-constant length, this value should be 100 (pipeline default). \nFastQC Analysis on FASTQ files reveals read length distribution. STAR can detect chimeric transcripts, but parameter \"Min segment length\" in \"Chimeric Alignments\" category must be adjusted to a desired minimum chimeric segment length. Aligned reads are reported in BAM format and can be viewed in a genome browser (such as IGV). A file containing detected splice junctions is also produced.\n\nUnmapped reads are reported in FASTQ format and can be included in an output BAM file. The \"Output unmapped reads\" and \"Write unmapped in SAM\" parameters enable unmapped output type selection.",
  "hints": [
    {
      "class": "sbg:AWSInstanceType",
      "value": "c3.8xlarge"
    }
  ]
}